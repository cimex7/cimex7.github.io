{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"183.从不订购的用户","text":"某网站包含两个表，Customers表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。SQL架构：12345678910Create table If Not Exists Customers (Id int, Name varchar(255))Create table If Not Exists Orders (Id int, CustomerId int)Truncate table Customersinsert into Customers (Id, Name) values ('1', 'Joe')insert into Customers (Id, Name) values ('2', 'Henry')insert into Customers (Id, Name) values ('3', 'Sam')insert into Customers (Id, Name) values ('4', 'Max')Truncate table Ordersinsert into Orders (Id, CustomerId) values ('1', '3')insert into Orders (Id, CustomerId) values ('2', '1') Customers 表：12345678+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+ Orders 表：123456+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+ 例如给定上述表格，你的查询应返回：123456+-----------+| Customers |+-----------+| Henry || Max |+-----------+ 思路 查询目标：Name（As Customers）查询范围：Customers表和Orders表查询条件：从不订购任何东西。 解答123456select Customers.Name as Customersfrom Customers left join Orders on Customers.Id = Orders.CustomerIdwhere Orders.Id is null","link":"/2019/04/29/183-从不订购的用户/"},{"title":"DNS","text":"域名和IP地址相互映射的一个分布式数据库打个比方就是一本记载名字和外号的字典","link":"/2019/04/02/DNS/"},{"title":"175.组合两个表","text":"SQL架构：123456Create table Person (PersonId int, FirstName varchar(255), LastName varchar(255))Create table Address (AddressId int, PersonId int, City varchar(255), State varchar(255))Truncate table Personinsert into Person (PersonId, LastName, FirstName) values ('1', 'Wang', 'Allen')Truncate table Addressinsert into Address (AddressId, PersonId, City, State) values ('1', '2', 'New York City', 'New York') 表1: Person：1234567+-------------+---------+| 列名 | 类型 |+-------------+---------+| PersonId | int || FirstName | varchar || LastName | varchar |+-------------+---------+ PersonId 是上表主键 表2: Address：12345678+-------------+---------+| 列名 | 类型 |+-------------+---------+| AddressId | int || PersonId | int || City | varchar || State | varchar |+-------------+---------+ AddressId 是上表主键 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于两表提供 person 的以下信息：1FirstName, LastName, City, State 思路 查询目标：Person表的FirstName, LastName, City, State查询范围：Person和Address 解答1234Select Person.FirstName, Person.LastName, Address.City, Address.State from Person LEFT JOIN Address ON Person.PersonId = Address.PersonId;","link":"/2019/04/27/175-组合两个表/"},{"title":"初识Django","text":"通常的WEB框架是MVC模式 Django框架是MTV模式 最简的开发流程","link":"/2019/03/22/Django-一/"},{"title":"Linux常用命令(一)","text":"ls命令就是list的缩写，通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等 常用参数搭配：ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 ls -r 反序排列 ls -t 以文件修改时间排序 ls -S 以文件大小排序 ls -h 以易读大小显示 ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 实例:(1) 按易读方式按时间反序排序，并显示文件详细信息 ls -lhrt (2) 按大小反序显示文件详细信息 ls -lrS (3)列出当前目录中所有以“t”开头的目录的详细内容 ls -l t* (4) 列出文件绝对路径（不包含隐藏文件） ls | sed &quot;s:^:`pwd`/:&quot; (5) 列出文件绝对路径（包含隐藏文件） find $pwd -maxdepth 1 | xargs ls -ld cd命令(changeDirectory),命令语法：cd [目录名]。说明：切换当前目录至dirName 实例:（1）进入要目录 cd / （2）进入”家”目录 cd ~ （3）进入上一次工作路径 cd - （4）把上个命令的参数作为cd参数使用。 cd !$ pwd命令查看当前工作目录路径 实例:（1）查看当前路径 pwd （2）查看软链接的实际路径 pwd -P mkdir命令创建文件夹 可用选项：-m: 对新建目录设置存取权限,也可以用chmod命令设置; -p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那 些尚不在的目录,即一次可以建立多个目录; 实例:（1）当前工作目录下创建名为t的文件夹 mkdir t （2）在tmp目录下创建路径为test/t1/t的目录，若不存在，则创建 mkdir -p /tmp/test/t1/t rm命令删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状 rm [选项] 文件… 实例:（1）删除任何.log文件；删除前逐一询问确认 rm -i *.log （2）删除test子目录及子目录中所有档案删除,并且不用一一确认 rm -rf test （3）删除以-f开头的文件 rm -- -f* rmdir命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。（注意：不能删除非空目录） 实例:（1）当parent子目录被删除后使它也成为空目录的话，则顺便一并删除 rmdir -p parent/child/child11 mv命令移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。当第二个参数为目录时，可刚多个文件以空格分隔作为第一参数，移动多个文件到参数2指定的目录中 实例:（1）将文件test.log重命名为test1.txt mv test.log test1.txt （2）将文件log1.txt,log2.txt,log3.txt移动到根的test3目录中 mv llog1.txt log2.txt log3.txt /test3 （3）将文件file1改名为file2，如果file2已经存在，则询问是否覆盖 mv -i log1.txt log2.txt （4）移动当前文件夹下的所有文件到上一级目录 mv * ../ cp命令将源文件复制至目标文件，或将多个源文件复制至目标目录。注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在shell脚本中，如果不加-i参数，则不会提示，而是直接覆盖！ -i 提示 -r 复制目录及目录内所有项目 -a 复制的文件与原文件时间一样 实例:（1）复制a.txt到test目录下，保持原文件时间,如果原文件存在提示是否覆盖 cp -ai a.txt test （2）为a.txt建议一个链接（快捷方式） cp -s a.txt link_a.txt cat命令cat主要有三大功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file -b对非空输出行号-n输出所有行号 实例:（1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里 cat -n log2012.log log2013.log （2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里 cat -b log2012.log log2013.log log.log （3）使用here doc生成新文件 cat &gt;log.txt &lt;&lt;EOF HelloWorldPWD=$(pwd)EOF ls -l log.txtcat log.txtHelloWorld PWD=/opt/soft/test （4）反向列示 tac log.txt PWD=/opt/soft/test World Hello more命令功能类似于cat, more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示 命令参数：+n 从笫n行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 ## 常用操作命令：Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 实例:（1）显示文件中从第3行起的内容 more +3 text.txt （2）在所列出文件目录详细信息，借助管道使每次显示5行 ls -l | more -5 按空格显示下5行 less命令less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 常用命令参数：i 忽略搜索时的大小写 -N 显示每行的行号 -o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来 -s 显示连续空行为一行 /字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） -x &lt;数字&gt; 将“tab”键显示为规定的数字空格 b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 实例:（1）ps查看进程信息并通过less分页显示 ps -aux | less -N （2）查看多个文件 ess 1.log 2.log 可以使用n查看下一个，使用p查看前一个","link":"/2019/03/14/Linux常用命令(一)/"},{"title":"Linux常用命令(二)","text":"head命令head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 常用参数：-n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数） 实例：（1）显示1.log文件中前20行 head 1.log -n 20 （2）显示1.log文件前20字节 head -c 20 log2014.log （3）显示t.log最后10行 head -n -10 t.log tail命令用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 常用参数：-f 循环读取（常用于查看递增的日志文件） -n&lt;行数&gt; 显示行数（从后向前） （1）循环读取逐渐增加的文件内容 ping 127.0.0.1 &gt; ping.log &amp;（后台运行：可使用jobs -l查看，也可使用fg将其移到前台运行） tail -f ping.log（查看日志）","link":"/2019/03/15/Linux常用命令(二)/"},{"title":"MongoDB数据库和集合的基本操作","text":"# MongoDB 简介 ## 简介MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富、最像关系数据库的。 ## 面向集合的存储在 MongoDB 中，一个数据库包含多个集合，类似于 MySQL 中一个数据库包含多个表；一个集合包含多个文档，类似于 MySQL 中一个表包含多条数据。 可以把集合记为表，文档记为一条记录。 这样命名是有原因的，因为 MongoDB 没有行列统一的表格式排列，而是采用一个大仓库的形式将所有数据包纳其中。文档也一样，它是一段自由独立的数据，受外部限制少，所以区别于关系型数据库的记录。 ## 虚拟机开机配置 启动 MongoDB 服务，因为 MongoDB 并不随系统一起启动，可能以下命令运行后会等一小段的时间才会启动完毕。 1sudo service mongodb start 在命令行中敲 exit 可以退出。 1mongo 基本概念数据库 一个 MongoDB 可以创建多个数据库 使用 show dbs 可以查看所有数据库的列表 执行 db 命令则可以查看当前数据库对象或者集合 运行 use 命令可以连接到指定的数据库 12$mongo # 进入到mongo命令行&gt;use test # 连接到test数据库 文档文档是 MongoDB 的核心，类似于 SQLite 数据库（关系数据库）中的每一行数据。多个键及其关联的值放在一起就是文档。在 Mongodb 中使用一种类 json 的 bson 存储数据，bson 数据可以理解为在 json 的基础上添加了一些 json 中没有的数据类型。 例如： 1{\"company\":\"Chenshi keji\"} 文档的逻辑联系假设有两个文档： 1234567891011121314# user文档{ \"name\": \"Tom Hanks\", \"contact\": \"987654321\", \"dob\": \"01-01-1991\"}# address文档{ \"building\": \"22 A, Indiana Apt\", \"pincode\": 123456, \"city\": \"chengdu\", \"state\": \"sichuan\"} 关系 1：嵌入式关系：把 address 文档嵌入到 user 文档中 12345678910111213141516171819# 这就是嵌入式的关系{ \"name\": \"Tom Hanks\", \"contact\": \"987654321\", \"dob\": \"01-01-1991\", \"address\": [{ \"building\": \"22 A, Indiana Apt\", \"pincode\": 123456, \"city\": \"chengdu\", \"state\": \"sichuan\" }, { \"building\": \"170 A, Acropolis Apt\", \"pincode\": 456789, \"city\": \"beijing\", \"state\": \"beijing\" }]} 关系 2：引用式关系：将两个文档分开，通过引用文档的_id 字段来建立关系 123456789# 这就是引用式关系{ \"name\": \"Tom Benzamin\", \"contact\": \"987654321\", \"dob\": \"01-01-1991\", \"address_ids\": [ ObjectId(\"52ffc4a5d85242602e000000\") #对应address文档的id字段 ]} 在实际应用的时候，嵌入式关系比较适合一对一的关系，引用式关系比较适合一对多或者多对多的情况。 集合集合就是一组文档的组合，就相当于是关系数据库中的表，在 MongoDB 中可以存储不同的文档结构的文档。 例如： 1{\"company\":\"Chenshi keji\"} {\"people\":\"man\",\"name\":\"peter\"}","link":"/2019/03/17/MongoDB操作(一)/"},{"title":"MySQL的安装","text":"SQL(Structured Query Language)是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统，同时也是数据库脚本文件的扩展名。 MySQL是一个关系型DBMS,使用SQL语言进行操作。 Ubuntu Linux 安装配置 MySQL安装环境：ubuntu-18.04.2 安装MySQL服务端，核心程序：1sudo apt-get install mysql-server 安装 MySQL 客户端：1sudo apt-get install mysql-client 验证是否安装成功：1sudo netstat -tap | grep mysql 用 gedit 修改 MySQL 的配置文件（my.cnf）：1sudo gedit /etc/mysql/my.cnf 打开 MySQL 服务并使用 root 用户登录：1234#启动MySQL服务sudo service mysql start#使用root用户登录mysql -u root -p password 查看数据库1show databases; 连接数据库1use &lt;数据库名&gt; 查看表1show tables; 退出1quit(exit)","link":"/2019/03/16/MySQL的安装/"},{"title":"TCP三次握手四次挥手","text":"三次握手 三次握手过程 B 处于 LISTEN 状态，等待来自 A 的连接请求。 A 向 B发送连接请求报文SYN(synchronize)。 B 收到 A 发来的 SYN，如果同意建立连接，则向 A 发送连接确认报文 SYN/ACK。 A 收到 SYN/ACK 后，再向B发出确认报文 ACK，代表握手结束。 B 收到 ACK 后，连接建立。 三次握手的原因第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 四次挥手四次挥手过程 A 发送连接释放报文 FIN。 B 收到 FIN 之后发出确认 ACK，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文 FIN。 A 收到 FIN 后发出确认 ACK，进入 TIME-WAIT 状态，等待 2 倍的 MSL（最大报文存活时间）后释放连接。 B 收到 ACK 后释放连接。 四次挥手的原因客户端发送了 FIN 连接释放报文之后，服务器端收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器端会发送 FIN 连接释放报文。 TIME_WAIT客户端接收到服务器端的 FIN 报文后进入此状态，而并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文 ACK 能够到达。如果服务器端没收到客户端发送来的确认报文 ACK，那么就需要重新发送连接释放请求报文 FIN，客户端等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本次连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文 SYN，从而错误打开连接。","link":"/2019/04/03/TCP-IP/"},{"title":"python之format()","text":"使用 按照默认顺序，不指定位置1print(\"{} {}\".format(\"hello\",\"world\") ) hello world 设置指定位置，可以多次使用1print(\"{0} {1} {0}\".format(\"hello\",\"or\")) hello or hello 使用列表格式化12person = {\"name\":\"opcai\",\"age\":20}print(\"My name is {name} . I am {age} years old .\".format(**person)) My name is opcai . I am 20 years old . 通过列表格式化12stu = [\"opcai\",\"linux\",\"MySQL\",\"Python\"]print(\"My name is {0[0]} , I love {0[1]} !\".format(stu)) My name is opcai , I love linux ! 数字格式化 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零(填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x(填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x(填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:10d} 13 右对齐(默认, 宽度为10) 13 {:&lt;10d} 13 左对齐(宽度为10) 13 {:^10d} 13 中间对齐(宽度为10) ^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。+表示在正数前显示+，负数前显示 -； （空格）表示在正数前加空格 进制转换 十进制 输出格式 对应进制输出 转换后进制 11 ‘{:b}’.format(11) 1011 二进制 11 ‘{:d}’.format(11) 11 十进制 11 ‘{:o}’.format(11) 13 八进 11 ‘{:x}’.format(11) b 十六进制 11 ‘{:#x}’.format(11) 0xb 十六进制 11 ‘{:#X}’.format(11) 0XB 十六进制 b、d、o、x 分别是二进制、十进制、八进制、十六进制。","link":"/2019/03/01/format用法/"},{"title":"git和github(一)基础操作","text":"git git三个分区和远程仓库关系","link":"/2019/04/10/git和github(一)基础操作/"},{"title":"hanoi问题","text":"分析用递归求解(A原始柱，B过渡柱，C目标柱)：1.当A只有一个时，A-&gt;C2.否则将n-1个从A先移动到B(C作为过渡柱)，然后再将这n-1个从B移动到C(A作为过渡柱) Python代码12345678910111213141516171819202122count = 0def hanoi(n, src, dst, mid): global count if n == 1: print(\"{}:{}-&gt;{}\".format(1, src, dst)) count += 1 else: hanoi(n-1, src, mid, dst) print(\"{}:{}-&gt;{}\".format(n, src, dst)) count += 1 hanoi(n-1, mid, dst, src)def main(): hanoi(3, \"A\", \"C\", \"B\") print(count)if __name__ == \"__main__\": main() 运行结果 移动示意图","link":"/2019/04/04/hanoi问题/"},{"title":"科赫雪花","text":"koch曲线12345678910111213141516171819202122232425import turtledef koch(size, n): if n == 0: turtle.fd(size) else: for angle in [0, 60, -120, 60]: turtle.left(angle) koch(size/3, n-1)def main(): turtle.setup(0.5,0.8) turtle.speed(0) turtle.penup() turtle.goto(-200, 100) turtle.pendown() turtle.pensize(2) koch(600,3) turtle.hideturtle() turtle.done()if __name__ == '__main__': main() koch雪花123456789101112131415161718192021222324252627282930import turtledef koch(size, n): if n == 0: turtle.fd(size) else: for angle in [0, 60, -120, 60]: turtle.left(angle) koch(size/3, n-1)def main(): turtle.setup(0.5,0.8) turtle.speed(0) turtle.penup() turtle.goto(-200, 100) turtle.pendown() turtle.pensize(2) level = 3 koch(400, level) turtle.right(120) koch(400, level) turtle.right(120) koch(400, level) turtle.hideturtle() turtle.done()if __name__ == '__main__': main()","link":"/2019/04/03/koch雪花/"},{"title":"数据库中的左连接(left join)和右连接(right join)区别","text":"Left Join / Right Join /inner join左连接where只影向右表，右连接where只影响左表。 Left Join12select * from tbl1 Left Join tbl2 where tbl1.ID = tbl2.ID 左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据。 简言之 Left Join影响到的是右边的表 Right Join12select * from tbl1 Right Join tbl2 where tbl1.ID = tbl2.ID 检索结果是tbl2的所有数据和tbl1中满足where 条件的数据。 简言之 Right Join影响到的是左边的表。 inner join12select * FROM tbl1 INNER JOIN tbl2 ON tbl1.ID = tbl2.ID 功能和 select * from tbl1,tbl2 where tbl1.id=tbl2.id相同。","link":"/2019/03/18/mysqljoin/"},{"title":"python之input()","text":"通过input()函数，可以从标准输入中读取内容，那么读到的内容是什么类型?通过type函数可以看到即使输入的int类型，input还是将其转换为字符串类型，那么如何将input的字符串类型转换为int类型？ 1.使用强制类型转换int()函数 2.使用eval()函数 eval()函数的用法见python之eval()不过eval()函数有一些潜在的风险，所以更推荐第一种方法来转换类型","link":"/2019/03/02/python之input/"},{"title":"python之eval()","text":"官方文档给出的功能解释：eval（）：将字符串string对象转化为有效的表达式参与求值运算返回计算结果 语法：调用的是：eval（expression，globals=None, locals=None）返回的是计算结果其中： * expression是一个参与计算的python表达式 * globals是可选的参数，如果设置属性不为None的话，就必须是dictionary对象了 * locals也是一个可选的对象，如果设置属性不为None的话，可以是任何map对象了 列表字符串，字典字符串，元组字符串的转换示例：1234567891011121314151617# encoding:utf-8import mathdef eval_test(): l = '[1,2,3,4,[5,6,7,8,9]]' d = \"{'a':123,'b':456,'c':789}\" t = '([1,3,5],[5,6,7,8,9],[123,456,789])' print(\"----转换前---------转换后----\") print(type(l), type(eval(l))) print(type(d), type(eval(d))) print(type(t), type(eval(t)))if __name__ == \"__main__\": eval_test()","link":"/2019/03/03/python之eval/"},{"title":"交换排序","text":"冒泡排序 伪码 123456789101112void BubbleSort(ElemType A[], int n){ for( i=0; i&lt;n-1; ++i){ flag=false; //交换是否发生的标志 for( i=0; j&gt;i; --j){ //一趟冒泡过程 if(A[j-1].key&gt;A[j].key){ //若为逆序 swap(A[j-1],A[j]); //交换 flag=true; } if(flag==false) return; //遍历没有发生，说明表已有序 }} 时间复杂度 空间复杂度 O(n^2) O(1) 稳定 中值排序 12345678910111213141516171819202122232425262728/** * 在线性时间，根据给定的中枢值重新组合子序列ar[left，right]， * 将中枢值存储在其正确的位置store，确保所有在子序列ar[left, store)中的 * 元素&lt;=pivot并且所有在ar[store+1, right]中的元素&gt;pivot。 */int partition (void **ar, int(*cmp)(const void *, const void *), nt left, int right, int pivotIndex) { nt idx, store; void *pivot = ar[pivotIndex]; /*将中枢值移动到数组结尾。*/ void *tmp = ar[right]; ar[right] = ar[pivotIndex]; ar[pivotIndex] = tmp;/*所有小于等于中枢值的元素都会移动到数组的前面，然后将中枢值插在它们后面。*/ store = left; for (idx = left; idx &lt; right; idx++) { if (cmp(ar[idx], pivot) &lt;= 0) { tmp = ar[idx]; ar[idx] = ar[store]; ar[store] = tmp; store++; } } mp = ar[right]; ar[right] = ar[store]; ar[store] = tmp; return store;} 快速排序","link":"/2019/04/05/交换排序/"},{"title":"使用PyInstaller库生成可执行文件","text":"首先安装PyInstaller库(cmd命令行) 1pip install pyinstaller 主要参数 修改图标并打包需要一个ico图标 在需要打包的文件根目录下使用命令1pyinstaller -i Digits.ico -F SevenDigits.py 打包完成需要的可执行文件在dist目录，如下","link":"/2019/03/02/使用PyInstaller库生成可执行文件/"},{"title":"http协议","text":"从输入url到页面加载的过程中发生了什么？ DNS解析url的ip地址发送HTTP请求TCP分割HTTP请求报文进行可靠的传输IP协议对请求报文进行中转和传送服务端TCP接受并重组报文服务端HTTP处理请求返回资源 示例","link":"/2019/04/02/各种协议与http协议的关系/"},{"title":"图片转字符","text":"代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding=utf-8 -*-from PIL import Imageimport argparse#命令行输入参数处理parser = argparse.ArgumentParser()parser.add_argument('file') #输入文件parser.add_argument('-o', '--output') #输出文件parser.add_argument('--width', type = int, default = 80) #输出字符画宽parser.add_argument('--height', type = int, default = 80) #输出字符画高#获取参数args = parser.parse_args()IMG = args.fileWIDTH = args.widthHEIGHT = args.heightOUTPUT = args.outputascii_char = list(\"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~&lt;&gt;i!lI;:,\\\"^`'. \")# 将256灰度映射到70个字符上def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)]if __name__ == '__main__': im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = \"\" for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += '\\n' print(txt) #字符画输出到文件 if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open(\"output.txt\",'w') as f: f.write(txt)","link":"/2019/03/20/图片转字符/"},{"title":"插入排序","text":"使用环境小规模数据需要排序，并且初始数据几乎是有序的(稳定) 代码实现假设ElemType为int C 基于值的插入排序1234567891011void insertSort(int arr[],int len){ int i,j; for(i=2;i&lt;n;i++){ //依次将arr[2]~arr[n]插入前面已排序的数列 if(arr[i]&lt;arr[i-1]){ //若arr[i]小于其前驱，则将其插入有序表 arr[0]=arr[i] //arr[0]不存放元素，复制为哨兵 for(j=i-1;arr[0]&lt;arr[j];--j) //从后往前查找待插入位置 arr[j+1]=arr[j]; //向后挪位 A[j+1]=A[0]; //将哨兵位置元素插入位置 } }} C 基于指针的插入排序1234567891011void insertSort(void **arr, int n, int(*cmp)(const void *){ int j; for(j=1; j&lt;n; j++){ int i=j--1; void *value =arr[j]; while(i&gt;=0&amp;&amp;cmp(arr[i], value)&gt;0){ arr[i+1] = arr[i]; i--; } arr[i+1] = value;} JAVA1234567891011public void insertSort(int[] array) { for (int i = 1; i &lt; array.length; i++) { int key = array[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) { array[j + 1] = array[j]; j--; } array[j + 1] = key; }} Python12345678910def insert_sort(lst): n=len(lst) if n==1: return lst for i in range(1,n): for j in range(i,0,-1): if lst[j]&lt;lst[j-1]: lst[j],lst[j-1]=lst[j-1],lst[j] else: break return lst 希尔排序改进版插入排序，不稳定 12345678910111213def shell_sort(list): n = len(list) gap = n // 2 # 初始步长 while gap &gt; 0: for i in range(gap, n): # 每个步长进行插入排序 temp = list[i] j = i while j &gt;= gap and list[j - gap] &gt; temp: # 插入排序 list[j] = list[j - gap] j -= gap list[j] = temp gap = gap // 2 # 得到新的步长 return list","link":"/2019/04/05/插入排序/"},{"title":"数据库操作","text":"初级数据库的操作123456789101112131415161718-- 查看当前数据库 SELECT DATABASE();-- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version();-- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name-- 查看已有库 SHOW DATABASES[ LIKE 'PATTERN']-- 查看当前库信息 SHOW CREATE DATABASE 数据库名-- 修改库的选项信息 ALTER DATABASE 库名 选项信息-- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容","link":"/2019/03/17/数据库操作/"},{"title":"表的操作","text":"初级表的操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576-- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']-- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = '目录' -- 索引文件目录 INDEX DIRECTORY = '目录' -- 表注释 COMMENT = 'string' -- 分区选项 PARTITION BY ... (详细见手册)-- 查看所有表 SHOW TABLES[ LIKE 'pattern'] SHOW TABLES FROM 表名-- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN'] SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern']-- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键-- 删除表 DROP TABLE[ IF EXISTS] 表名 ...-- 清空表数据 TRUNCATE [TABLE] 表名-- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名-- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名-- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ...-- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...-- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]-- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...","link":"/2019/03/17/表的操作/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"网络","slug":"网络","link":"/tags/网络/"},{"name":"基础","slug":"基础","link":"/tags/基础/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"turtle","slug":"turtle","link":"/tags/turtle/"},{"name":"递归","slug":"递归","link":"/tags/递归/"},{"name":"分形几何","slug":"分形几何","link":"/tags/分形几何/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"数组","slug":"数组","link":"/tags/数组/"},{"name":"分治","slug":"分治","link":"/tags/分治/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/计算机网络/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"数据库","slug":"LeetCode/数据库","link":"/categories/LeetCode/数据库/"},{"name":"操作系统","slug":"操作系统","link":"/categories/操作系统/"},{"name":"DNS","slug":"计算机网络/DNS","link":"/categories/计算机网络/DNS/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"TCP/IP","slug":"计算机网络/TCP-IP","link":"/categories/计算机网络/TCP-IP/"},{"name":"常用函数","slug":"Python/常用函数","link":"/categories/Python/常用函数/"},{"name":"Django","slug":"Python/Django","link":"/categories/Python/Django/"},{"name":"版本控制","slug":"版本控制","link":"/categories/版本控制/"},{"name":"数据结构和算法","slug":"数据结构和算法","link":"/categories/数据结构和算法/"},{"name":"常用库","slug":"Python/常用库","link":"/categories/Python/常用库/"},{"name":"Linux","slug":"操作系统/Linux","link":"/categories/操作系统/Linux/"},{"name":"HTTP","slug":"计算机网络/HTTP","link":"/categories/计算机网络/HTTP/"},{"name":"MongoDB","slug":"数据库/MongoDB","link":"/categories/数据库/MongoDB/"},{"name":"MySQL","slug":"数据库/MySQL","link":"/categories/数据库/MySQL/"},{"name":"GIT","slug":"版本控制/GIT","link":"/categories/版本控制/GIT/"},{"name":"递归","slug":"数据结构和算法/递归","link":"/categories/数据结构和算法/递归/"},{"name":"排序","slug":"数据结构和算法/排序","link":"/categories/数据结构和算法/排序/"}]}