{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"DNS","text":"域名和IP地址相互映射的一个分布式数据库打个比方就是一本记载名字和外号的字典","link":"/2019/04/02/DNS/"},{"title":"搭建开发环境","text":"","link":"/2019/03/23/Django项目(一)/"},{"title":"Linux常用命令(一)","text":"ls命令就是list的缩写，通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等 常用参数搭配：ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 ls -r 反序排列 ls -t 以文件修改时间排序 ls -S 以文件大小排序 ls -h 以易读大小显示 ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 实例:(1) 按易读方式按时间反序排序，并显示文件详细信息 ls -lhrt (2) 按大小反序显示文件详细信息 ls -lrS (3)列出当前目录中所有以“t”开头的目录的详细内容 ls -l t* (4) 列出文件绝对路径（不包含隐藏文件） ls | sed &quot;s:^:`pwd`/:&quot; (5) 列出文件绝对路径（包含隐藏文件） find $pwd -maxdepth 1 | xargs ls -ld cd命令(changeDirectory),命令语法：cd [目录名]。说明：切换当前目录至dirName 实例:（1）进入要目录 cd / （2）进入”家”目录 cd ~ （3）进入上一次工作路径 cd - （4）把上个命令的参数作为cd参数使用。 cd !$ pwd命令查看当前工作目录路径 实例:（1）查看当前路径 pwd （2）查看软链接的实际路径 pwd -P mkdir命令创建文件夹 可用选项：-m: 对新建目录设置存取权限,也可以用chmod命令设置; -p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那 些尚不在的目录,即一次可以建立多个目录; 实例:（1）当前工作目录下创建名为t的文件夹 mkdir t （2）在tmp目录下创建路径为test/t1/t的目录，若不存在，则创建 mkdir -p /tmp/test/t1/t rm命令删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状 rm [选项] 文件… 实例:（1）删除任何.log文件；删除前逐一询问确认 rm -i *.log （2）删除test子目录及子目录中所有档案删除,并且不用一一确认 rm -rf test （3）删除以-f开头的文件 rm -- -f* rmdir命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。（注意：不能删除非空目录） 实例:（1）当parent子目录被删除后使它也成为空目录的话，则顺便一并删除 rmdir -p parent/child/child11 mv命令移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。当第二个参数为目录时，可刚多个文件以空格分隔作为第一参数，移动多个文件到参数2指定的目录中 实例:（1）将文件test.log重命名为test1.txt mv test.log test1.txt （2）将文件log1.txt,log2.txt,log3.txt移动到根的test3目录中 mv llog1.txt log2.txt log3.txt /test3 （3）将文件file1改名为file2，如果file2已经存在，则询问是否覆盖 mv -i log1.txt log2.txt （4）移动当前文件夹下的所有文件到上一级目录 mv * ../ cp命令将源文件复制至目标文件，或将多个源文件复制至目标目录。注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在shell脚本中，如果不加-i参数，则不会提示，而是直接覆盖！ -i 提示 -r 复制目录及目录内所有项目 -a 复制的文件与原文件时间一样 实例:（1）复制a.txt到test目录下，保持原文件时间,如果原文件存在提示是否覆盖 cp -ai a.txt test （2）为a.txt建议一个链接（快捷方式） cp -s a.txt link_a.txt cat命令cat主要有三大功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file -b对非空输出行号-n输出所有行号 实例:（1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里 cat -n log2012.log log2013.log （2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里 cat -b log2012.log log2013.log log.log （3）使用here doc生成新文件 cat &gt;log.txt &lt;&lt;EOF HelloWorldPWD=$(pwd)EOF ls -l log.txtcat log.txtHelloWorld PWD=/opt/soft/test （4）反向列示 tac log.txt PWD=/opt/soft/test World Hello more命令功能类似于cat, more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示 命令参数：+n 从笫n行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 ## 常用操作命令：Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 实例:（1）显示文件中从第3行起的内容 more +3 text.txt （2）在所列出文件目录详细信息，借助管道使每次显示5行 ls -l | more -5 按空格显示下5行 less命令less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 常用命令参数：i 忽略搜索时的大小写 -N 显示每行的行号 -o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来 -s 显示连续空行为一行 /字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） -x &lt;数字&gt; 将“tab”键显示为规定的数字空格 b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 实例:（1）ps查看进程信息并通过less分页显示 ps -aux | less -N （2）查看多个文件 ess 1.log 2.log 可以使用n查看下一个，使用p查看前一个","link":"/2019/03/14/Linux常用命令(一)/"},{"title":"Linux常用命令(二)","text":"head命令head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 常用参数：-n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数） 实例：（1）显示1.log文件中前20行 head 1.log -n 20 （2）显示1.log文件前20字节 head -c 20 log2014.log （3）显示t.log最后10行 head -n -10 t.log tail命令用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 常用参数：-f 循环读取（常用于查看递增的日志文件） -n&lt;行数&gt; 显示行数（从后向前） （1）循环读取逐渐增加的文件内容 ping 127.0.0.1 &gt; ping.log &amp;（后台运行：可使用jobs -l查看，也可使用fg将其移到前台运行） tail -f ping.log（查看日志）","link":"/2019/03/15/Linux常用命令(二)/"},{"title":"TCP三次握手四次挥手","text":"三次握手(three-way handshaking) 三次握手过程 B 处于 LISTEN 状态，等待来自 A 的连接请求。 A 向 B发送连接请求报文SYN(synchronize)。 B 收到 A 发来的 SYN，如果同意建立连接，则向 A 发送连接确认报文 SYN/ACK(ackonwledgement)。 A 收到 SYN/ACK 后，再向B发出确认报文 ACK，代表握手结束。 B 收到 ACK 后，连接建立。 三次握手的原因第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 四次挥手四次挥手过程 A 发送连接释放报文 FIN。 B 收到 FIN 之后发出确认 ACK，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文 FIN。 A 收到 FIN 后发出确认 ACK，进入 TIME-WAIT 状态，等待 2 倍的 MSL（最大报文存活时间）后释放连接。 B 收到 ACK 后释放连接。 四次挥手的原因客户端发送了 FIN 连接释放报文之后，服务器端收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器端会发送 FIN 连接释放报文。 TIME_WAIT客户端接收到服务器端的 FIN 报文后进入此状态，而并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文 ACK 能够到达。如果服务器端没收到客户端发送来的确认报文 ACK，那么就需要重新发送连接释放请求报文 FIN，客户端等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本次连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文 SYN，从而错误打开连接。","link":"/2019/04/03/TCP-IP/"},{"title":"MySQL的安装","text":"SQL(Structured Query Language)是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统，同时也是数据库脚本文件的扩展名。 MySQL是一个关系型DBMS,使用SQL语言进行操作。 Ubuntu Linux 安装配置 MySQL安装环境：ubuntu-18.04.2 安装MySQL服务端，核心程序：1sudo apt-get install mysql-server 安装 MySQL 客户端：1sudo apt-get install mysql-client 验证是否安装成功：1sudo netstat -tap | grep mysql 用 gedit 修改 MySQL 的配置文件（my.cnf）：1sudo gedit /etc/mysql/my.cnf 打开 MySQL 服务并使用 root 用户登录：1234#启动MySQL服务sudo service mysql start#使用root用户登录mysql -u root -p password 查看数据库1show databases; 连接数据库1use &lt;数据库名&gt; 查看表1show tables; 退出1quit(exit)","link":"/2019/03/16/MySQL的安装/"},{"title":"MongoDB数据库和集合的基本操作","text":"# MongoDB 简介 ## 简介MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富、最像关系数据库的。 ## 面向集合的存储在 MongoDB 中，一个数据库包含多个集合，类似于 MySQL 中一个数据库包含多个表；一个集合包含多个文档，类似于 MySQL 中一个表包含多条数据。 可以把集合记为表，文档记为一条记录。 这样命名是有原因的，因为 MongoDB 没有行列统一的表格式排列，而是采用一个大仓库的形式将所有数据包纳其中。文档也一样，它是一段自由独立的数据，受外部限制少，所以区别于关系型数据库的记录。 ## 虚拟机开机配置 启动 MongoDB 服务，因为 MongoDB 并不随系统一起启动，可能以下命令运行后会等一小段的时间才会启动完毕。 1sudo service mongodb start 在命令行中敲 exit 可以退出。 1mongo 基本概念数据库 一个 MongoDB 可以创建多个数据库 使用 show dbs 可以查看所有数据库的列表 执行 db 命令则可以查看当前数据库对象或者集合 运行 use 命令可以连接到指定的数据库 12$mongo # 进入到mongo命令行&gt;use test # 连接到test数据库 文档文档是 MongoDB 的核心，类似于 SQLite 数据库（关系数据库）中的每一行数据。多个键及其关联的值放在一起就是文档。在 Mongodb 中使用一种类 json 的 bson 存储数据，bson 数据可以理解为在 json 的基础上添加了一些 json 中没有的数据类型。 例如： 1{\"company\":\"Chenshi keji\"} 文档的逻辑联系假设有两个文档： 1234567891011121314# user文档{ \"name\": \"Tom Hanks\", \"contact\": \"987654321\", \"dob\": \"01-01-1991\"}# address文档{ \"building\": \"22 A, Indiana Apt\", \"pincode\": 123456, \"city\": \"chengdu\", \"state\": \"sichuan\"} 关系 1：嵌入式关系：把 address 文档嵌入到 user 文档中 12345678910111213141516171819# 这就是嵌入式的关系{ \"name\": \"Tom Hanks\", \"contact\": \"987654321\", \"dob\": \"01-01-1991\", \"address\": [{ \"building\": \"22 A, Indiana Apt\", \"pincode\": 123456, \"city\": \"chengdu\", \"state\": \"sichuan\" }, { \"building\": \"170 A, Acropolis Apt\", \"pincode\": 456789, \"city\": \"beijing\", \"state\": \"beijing\" }]} 关系 2：引用式关系：将两个文档分开，通过引用文档的_id 字段来建立关系 123456789# 这就是引用式关系{ \"name\": \"Tom Benzamin\", \"contact\": \"987654321\", \"dob\": \"01-01-1991\", \"address_ids\": [ ObjectId(\"52ffc4a5d85242602e000000\") #对应address文档的id字段 ]} 在实际应用的时候，嵌入式关系比较适合一对一的关系，引用式关系比较适合一对多或者多对多的情况。 集合集合就是一组文档的组合，就相当于是关系数据库中的表，在 MongoDB 中可以存储不同的文档结构的文档。 例如： 1{\"company\":\"Chenshi keji\"} {\"people\":\"man\",\"name\":\"peter\"}","link":"/2019/03/17/MongoDB操作(一)/"},{"title":"git和github(一)基础操作","text":"","link":"/2019/04/17/git和github(一)基础操作/"},{"title":"hanoi问题","text":"分析用递归求解(A原始柱，B过渡柱，C目标柱)：1.当A只有一个时，A-&gt;C2.否则将n-1个从A先移动到B(C作为过渡柱)，然后再将这n-1个从B移动到C(A作为过渡柱) Python代码12345678910111213141516171819202122count = 0def hanoi(n, src, dst, mid): global count if n == 1: print(\"{}:{}-&gt;{}\".format(1, src, dst)) count += 1 else: hanoi(n-1, src, mid, dst) print(\"{}:{}-&gt;{}\".format(n, src, dst)) count += 1 hanoi(n-1, mid, dst, src)def main(): hanoi(3, \"A\", \"C\", \"B\") print(count)if __name__ == \"__main__\": main() 运行结果 移动示意图","link":"/2019/04/18/hanoi问题/"},{"title":"交换排序","text":"冒泡排序 伪码 123456789101112void BubbleSort(ElemType A[], int n){ for( i=0; i&lt;n-1; ++i){ flag=false; //交换是否发生的标志 for( i=0; j&gt;i; --j){ //一趟冒泡过程 if(A[j-1].key&gt;A[j].key){ //若为逆序 swap(A[j-1],A[j]); //交换 flag=true; } if(flag==false) return; //遍历没有发生，说明表已有序 }} 时间复杂度 空间复杂度 O(n^2) O(1) 稳定 中值排序 12345678910111213141516171819202122232425262728/** * 在线性时间，根据给定的中枢值重新组合子序列ar[left，right]， * 将中枢值存储在其正确的位置store，确保所有在子序列ar[left, store)中的 * 元素&lt;=pivot并且所有在ar[store+1, right]中的元素&gt;pivot。 */int partition (void **ar, int(*cmp)(const void *, const void *), nt left, int right, int pivotIndex) { nt idx, store; void *pivot = ar[pivotIndex]; /*将中枢值移动到数组结尾。*/ void *tmp = ar[right]; ar[right] = ar[pivotIndex]; ar[pivotIndex] = tmp;/*所有小于等于中枢值的元素都会移动到数组的前面，然后将中枢值插在它们后面。*/ store = left; for (idx = left; idx &lt; right; idx++) { if (cmp(ar[idx], pivot) &lt;= 0) { tmp = ar[idx]; ar[idx] = ar[store]; ar[store] = tmp; store++; } } mp = ar[right]; ar[right] = ar[store]; ar[store] = tmp; return store;} 快速排序","link":"/2019/04/05/交换排序/"},{"title":"动态规划","text":"实例背包问题 背包问题作为NP完全问题，暂时不存在多项式时间算法。动态规划属于背包问题求解最优解的可行方法之一。此外，求解背包问题最优解还有搜索法等，近似解还有贪心法等，分数背包问题有最优贪心解等。背包问题具有最优子结构和重叠子问题。动态规划一般用于求解背包问题中的整数背包问题（即每种物品所选的个数必须是整数）。解整数背包问题： 设有n件物品，每件价值记为P_i ，每件体积记为V_i ，用一个最大容积为V_max的背包，求装入物品的最大价值。 用一个数组f[i,v]}表示取i件商品填充一个容积为v的背包的最大价值，显然问题的解就是f[n,V_max]。对于特例01背包问题（即每件物品最多放1件，否则不放入）的问题，状态转移方程： C++代码（不含include和数组声明）12345#define max(x,y) (x)&gt;(y)?(x):(y) //max宏函数，也可以自己写或者调取algorithmfor(int i=1;i&lt;=n;i++) for (v=totv;v&gt;=v[i];v--) f[v]=max(f[v],f[v-v[i]]+p[i]);printf(\"%d\",f[totv]); //或std:cout&lt;&lt;f[totv];","link":"/2019/04/07/动态规划/"},{"title":"各种协议与http协议的关系","text":"从输入url到页面加载的过程中发生了什么？ DNS解析url的ip地址发送HTTP请求TCP分割HTTP请求报文进行可靠的传输IP协议对请求报文进行中转和传送服务端TCP接受并重组报文服务端HTTP处理请求返回资源 示例","link":"/2019/04/02/各种协议与http协议的关系/"},{"title":"图片转字符","text":"代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding=utf-8 -*-from PIL import Imageimport argparse#命令行输入参数处理parser = argparse.ArgumentParser()parser.add_argument('file') #输入文件parser.add_argument('-o', '--output') #输出文件parser.add_argument('--width', type = int, default = 80) #输出字符画宽parser.add_argument('--height', type = int, default = 80) #输出字符画高#获取参数args = parser.parse_args()IMG = args.fileWIDTH = args.widthHEIGHT = args.heightOUTPUT = args.outputascii_char = list(\"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~&lt;&gt;i!lI;:,\\\"^`'. \")# 将256灰度映射到70个字符上def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)]if __name__ == '__main__': im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = \"\" for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += '\\n' print(txt) #字符画输出到文件 if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open(\"output.txt\",'w') as f: f.write(txt)","link":"/2019/04/08/图片转字符/"},{"title":"插入排序","text":"使用环境 小规模数据需要排序，并且初始数据几乎是有序的(稳定) 代码实现假设ElemType为int C 基于值的插入排序1234567891011void insertSort(int arr[],int len){ int i,j; for(i=2;i&lt;n;i++){ //依次将arr[2]~arr[n]插入前面已排序的数列 if(arr[i]&lt;arr[i-1]){ //若arr[i]小于其前驱，则将其插入有序表 arr[0]=arr[i] //arr[0]不存放元素，复制为哨兵 for(j=i-1;arr[0]&lt;arr[j];--j) //从后往前查找待插入位置 arr[j+1]=arr[j]; //向后挪位 A[j+1]=A[0]; //将哨兵位置元素插入位置 } }} C 基于指针的插入排序1234567891011void insertSort(void **arr, int n, int(*cmp)(const void *){ int j; for(j=1; j&lt;n; j++){ int i=j--1; void *value =arr[j]; while(i&gt;=0&amp;&amp;cmp(arr[i], value)&gt;0){ arr[i+1] = arr[i]; i--; } arr[i+1] = value;} JAVA1234567891011public void insertSort(int[] array) { for (int i = 1; i &lt; array.length; i++) { int key = array[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) { array[j + 1] = array[j]; j--; } array[j + 1] = key; }} Python12345678910def insert_sort(lst): n=len(lst) if n==1: return lst for i in range(1,n): for j in range(i,0,-1): if lst[j]&lt;lst[j-1]: lst[j],lst[j-1]=lst[j-1],lst[j] else: break return lst 希尔排序改进版插入排序，不稳定 12345678910111213def shell_sort(list): n = len(list) gap = n // 2 # 初始步长 while gap &gt; 0: for i in range(gap, n): # 每个步长进行插入排序 temp = list[i] j = i while j &gt;= gap and list[j - gap] &gt; temp: # 插入排序 list[j] = list[j - gap] j -= gap list[j] = temp gap = gap // 2 # 得到新的步长 return list","link":"/2019/04/05/插入排序/"},{"title":"数据库操作","text":"123456789101112131415161718-- 查看当前数据库 SELECT DATABASE();-- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version();-- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name-- 查看已有库 SHOW DATABASES[ LIKE 'PATTERN']-- 查看当前库信息 SHOW CREATE DATABASE 数据库名-- 修改库的选项信息 ALTER DATABASE 库名 选项信息-- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容","link":"/2019/03/17/数据库操作/"},{"title":"表的操作","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576-- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']-- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = '目录' -- 索引文件目录 INDEX DIRECTORY = '目录' -- 表注释 COMMENT = 'string' -- 分区选项 PARTITION BY ... (详细见手册)-- 查看所有表 SHOW TABLES[ LIKE 'pattern'] SHOW TABLES FROM 表名-- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN'] SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern']-- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键-- 删除表 DROP TABLE[ IF EXISTS] 表名 ...-- 清空表数据 TRUNCATE [TABLE] 表名-- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名-- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名-- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ...-- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...-- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]-- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...","link":"/2019/03/17/表的操作/"},{"title":"贪心","text":"简介贪心算法（greedy algorithm)是一种短视的算法，每一个选择都是独立的，都是当前环境下能采取的最佳策略。 实现步骤1.创建数学模型来描述问题。2.把求解的问题分成若干个子问题。3.对每一子问题求解，得到子问题的局部最优解。4.把子问题的解局部最优解合成原来解问题的一个解。 例子最小生成树的算法：Prim MST、Kruskal MST单源最短路径：Djikstra’s","link":"/2019/04/06/贪心/"}],"tags":[{"name":"基础","slug":"基础","link":"/tags/基础/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"数组","slug":"数组","link":"/tags/数组/"},{"name":"分治","slug":"分治","link":"/tags/分治/"},{"name":"递归","slug":"递归","link":"/tags/递归/"},{"name":"网络","slug":"网络","link":"/tags/网络/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"计算机网络","slug":"计算机网络","link":"/categories/计算机网络/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"操作系统","slug":"操作系统","link":"/categories/操作系统/"},{"name":"DNS","slug":"计算机网络/DNS","link":"/categories/计算机网络/DNS/"},{"name":"TCP/IP","slug":"计算机网络/TCP-IP","link":"/categories/计算机网络/TCP-IP/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"Django框架","slug":"Python/Django框架","link":"/categories/Python/Django框架/"},{"name":"版本控制","slug":"版本控制","link":"/categories/版本控制/"},{"name":"Linux","slug":"操作系统/Linux","link":"/categories/操作系统/Linux/"},{"name":"数据结构和算法","slug":"数据结构和算法","link":"/categories/数据结构和算法/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"MySQL","slug":"数据库/MySQL","link":"/categories/数据库/MySQL/"},{"name":"MongoDB","slug":"数据库/MongoDB","link":"/categories/数据库/MongoDB/"},{"name":"git","slug":"版本控制/git","link":"/categories/版本控制/git/"},{"name":"递归","slug":"数据结构和算法/递归","link":"/categories/数据结构和算法/递归/"},{"name":"排序","slug":"算法/排序","link":"/categories/算法/排序/"},{"name":"动态规划","slug":"算法/动态规划","link":"/categories/算法/动态规划/"},{"name":"贪心","slug":"算法/贪心","link":"/categories/算法/贪心/"},{"name":"动态规划","slug":"数据结构和算法/动态规划","link":"/categories/数据结构和算法/动态规划/"},{"name":"排序","slug":"数据结构和算法/排序","link":"/categories/数据结构和算法/排序/"},{"name":"贪心","slug":"数据结构和算法/贪心","link":"/categories/数据结构和算法/贪心/"}]}